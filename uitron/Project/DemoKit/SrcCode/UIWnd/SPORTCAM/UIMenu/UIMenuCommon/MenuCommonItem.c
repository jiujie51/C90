//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "UIGraphics.h"
#include "NVTToolCommand.h"
#include "MenuCommonItemRes.c"
#include "MenuCommonItem.h"
#include "PrjCfg.h"
#include "UIFlow.h"
#include "EthCamAppCmd.h"

extern UINT32 System_GetEnableSensor(void);

//---------------------MenuCommonItemCtrl Debug Definition -----------------------------
#define _MENUCOMMONITEM_ERROR_MSG        1
#define _MENUCOMMONITEM_TRACE_MSG        0

#if (_MENUCOMMONITEM_ERROR_MSG&(PRJ_DBG_LVL>=PRJ_DBG_LVL_ERR))
#define MenuCommonItemErrMsg(...)            debug_msg ("^R MenuCommonItem: "__VA_ARGS__)
#else
#define MenuCommonItemErrMsg(...)
#endif

#if (_MENUCOMMONITEM_TRACE_MSG&(PRJ_DBG_LVL>=PRJ_DBG_LVL_TRC))
#define MenuCommonItemTraceMsg(...)          debug_msg ("^B MenuCommonItem: "__VA_ARGS__)
#else
#define MenuCommonItemTraceMsg(...)
#endif

//---------------------MenuCommonItemCtrl Global Variables -----------------------------
#define PAGE           12
//---------------------MenuCommonItemCtrl Prototype Declaration  -----------------------
#if defined(_KEY_METHOD_4KEY_)
#define MENU_KEY_PRESS_MASK        (FLGKEY_UP|FLGKEY_DOWN|FLGKEY_RIGHT|FLGKEY_SHUTTER2)
#define MENU_KEY_RELEASE_MASK      (FLGKEY_UP|FLGKEY_DOWN|FLGKEY_RIGHT|FLGKEY_SHUTTER2)
#define MENU_KEY_CONTINUE_MASK     (FLGKEY_UP|FLGKEY_DOWN|FLGKEY_RIGHT|FLGKEY_SHUTTER2)
#else
#define MENU_KEY_PRESS_MASK        (FLGKEY_LEFT|FLGKEY_RIGHT)
#define MENU_KEY_RELEASE_MASK      (FLGKEY_LEFT|FLGKEY_RIGHT)
#define MENU_KEY_CONTINUE_MASK     (FLGKEY_LEFT|FLGKEY_RIGHT)
#endif
//---------------------MenuCommonItemCtrl Public API  ----------------------------------


static UINT32 MenuCommonItem_List_CalcShiftFrom1stItem(UINT32 x, UINT32 y, Ux_RECT* ListRect, UINT32 item_per_line, UINT32 colum_total);


//---------------------MenuCommonItemCtrl Private API  ---------------------------------
static TM_MENU *g_pItemMenu = 0;

static void MenuCommonItem_SetCurrentMenu(TM_MENU *pMenu)
{
	g_pItemMenu = pMenu;
}
static TM_MENU *MenuCommonItem_GetCurrentMenu(void)
{
	return g_pItemMenu;
}


UINT32 MenuCommonItem_GetSubValueIconId(UINT16 ItemId)
{
    UINT32      SubValueId = 0;
    TM_PAGE*    pPage;
    TM_MENU*    pMenu = MenuCommonItem_GetCurrentMenu();
    //TM_ITEM*    pSelItem;
    pPage = &pMenu->pPages[pMenu->SelPage];
    //TM_CheckItemStatus(pMenu, &ItemId, TRUE);

    UINT16 uiCurItem, uiItemTextId_Focus;
    uiCurItem = UxList_GetData(&MenuCommonItem_ListCtrl, LST_CURITM);
    uiItemTextId_Focus = UxList_GetItemData(&MenuCommonItem_ListCtrl, uiCurItem, LSTITM_STRID);
    //TESTLOG("%d, %d", uiItemTextId_Focus, ItemId);
    
    if (pPage->IconId == ICON_SETUP)
    {
        switch(ItemId)
        {
            case IDS_APP:
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_APP_F;
                } else {
                    SubValueId = ICON_SETUP_APP;
                }
                break;

            case IDS_WIFIINFO:
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_WIFIINFO_F;
                } else {
                    SubValueId = ICON_SETUP_WIFIINFO;
                }
                break;

            case IDS_WIFI:
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_WIFI_F;
                } else {
                    SubValueId = ICON_SETUP_WIFI;
                }
                break;

            case IDS_DATE_TIME:
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_DATE_F;
                } else {
                    SubValueId = ICON_SETUP_DATE;
                }
                break;
				
			case IDS_MOVIE_AUDIO: 
				if(uiItemTextId_Focus == ItemId){
					SubValueId = ICON_SETUP_AUDIO_F;
				} else {
					SubValueId = ICON_SETUP_AUDIO;
				}
				break;
								
			case IDS_MOVIE_CYCLIC_REC: 
				if(uiItemTextId_Focus == ItemId){
					SubValueId = ICON_SETUP_CYCLIC_F;
				} else {
					SubValueId = ICON_SETUP_CYCLIC;
				}
				break;
				
			case IDS_VOLUME: 
				if(uiItemTextId_Focus == ItemId){
					SubValueId = ICON_SETUP_VOLUME_F;
				} else {
					SubValueId = ICON_SETUP_VOLUME;
				}
				break;
					
            case IDS_URGSENSE: 
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_URGSENSE_F;
                } else {
                    SubValueId = ICON_SETUP_URGSENSE;
                }
                break;
 
            case IDS_PARK: 
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_PARK_F;
                } else {
                    SubValueId = ICON_SETUP_PARK;
                }
                break;
                 
            case IDS_ALARM: 
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_ALARM_F;
                } else {
                    SubValueId = ICON_SETUP_ALARM;
                }
                break;

			#if(_ANFA_ADAS_MENU_)
			case IDS_ANFA_ADAS:
				if(uiItemTextId_Focus == ItemId){
					CHKPNT;
					SubValueId = ICON_SETUP_ANFA_ADAS_F;
				}else{
					SubValueId = ICON_SETUP_ANFA_ADAS;
				}
				break;
			#endif
			case IDS_MOVIE_BACKADJUST: 
                if(uiItemTextId_Focus == ItemId){
					CHKPNT;
                    SubValueId = ICON_MENU_BACKLIGHT_F;
                } else {
                    SubValueId = ICON_MENU_BACKLIGHT;
                }
                break;
				
             case IDS_FORMAT:
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_FORMAT_F;
                } else {
                    SubValueId = ICON_SETUP_FORMAT;
                }
                break;
				
            case IDS_DEFAULT:
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_RESET_F;
                } else {
                    SubValueId = ICON_SETUP_RESET;
                }
                break;
 
            case IDS_VERSION: 
                if(uiItemTextId_Focus == ItemId){
                    SubValueId = ICON_SETUP_ABOUT_F;
                } else {
                    SubValueId = ICON_SETUP_ABOUT;
                }
                break;
				
			case IDS_MOVIE_SIZE: 
				if(uiItemTextId_Focus == ItemId){
					SubValueId = ICON_SETUP_MOVIESIZE_F;
				} else {
					SubValueId = ICON_SETUP_MOVIESIZE;
				}
				break;
				
			case IDS_SCREENLIGHT: 
				if(uiItemTextId_Focus == ItemId){
					SubValueId = ICON_SETUP_SCREENLIGHT_F;
				} else {
					SubValueId = ICON_SETUP_SCREENLIGHT;
				}
				break;
            default:
                break;
   
        }
    }
    //TESTLOG("ItemId: %d, ICONID: %d, %d", ItemId, SubValueId, pPage->IconId);
                
    return SubValueId;
}

static void MenuCommonItem_UpdateContent(TM_MENU *pMenu)
{
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;
	TM_OPTION  *pOption;
	UINT32      i;
	UINT16      startIndex = 0;
	UINT16      itemIndex = 0;

	pPage = &pMenu->pPages[pMenu->SelPage];
	pItem = &pPage->pItems[pPage->SelItem];
	pOption = &pItem->pOptions[SysGetFlag(pItem->SysFlag)];

	//find startIndex
	TM_FindStartIndex(pMenu, PAGE, &startIndex);

	//draw item form startIndex
	itemIndex = startIndex;
	for (i = 0; i < PAGE; i++) {
		//check item if disable
		TM_CheckItemStatus(pMenu, &itemIndex, TRUE);
		if ((itemIndex == pPage->Count) && (i < PAGE)) {
			UxList_SetItemData(&MenuCommonItem_ListCtrl, i, LSTITM_STATUS, STATUS_DISABLE);
		} else {
			pItem = &pPage->pItems[itemIndex];
			UxList_SetItemData(&MenuCommonItem_ListCtrl, i, LSTITM_STATUS, STATUS_ENABLE);
			UxList_SetItemData(&MenuCommonItem_ListCtrl, i, LSTITM_STRID,  pItem->TextId);
            //UxList_SetItemData(&MenuCommonItem_ListCtrl, i, LSTITM_ICONID, MenuCommonItem_GetSubValueIconId(pItem->ItemId));
            UxList_SetItemData(&MenuCommonItem_ListCtrl, i, LSTITM_ICONID, MenuCommonItem_GetSubValueIconId(pItem->TextId));
			itemIndex++;
		}
	}
}
static void MenuCommonItem_UpdatePosition(void)
{
	ISIZE str_size;
    //#MT#lyb -20200317 -begin
	//Ux_RECT MenuRect, NewRect;
	UINT32 strId = 0;//UxMenu_GetItemData(&MenuCommonItem_TitleCtrl, CURITEM_INDEX, MNUITM_STRID);
    //#MT#lyb -20200317 -end

#if (!defined(_NVT_ETHREARCAM_TX_))
	//avoid other tmp UI change font table
	GxGfx_SetTextStroke((const FONT *)gDemoKit_Font, FONTSTYLE_NORMAL, SCALE_1X);
#endif
	if (strId & TEXT_POINTER) {
		strId = (strId) & ~TEXT_POINTER;
		GxGfx_TextPrint(0, 0, 0, "%s", strId);
	} else {
		GxGfx_Text(0, 0, 0, GxGfx_GetStringID(strId));
	}

	str_size = GxGfx_GetTextLastSize();
//#MT#lyb -20200317 -begin
#if 0
	UxCtrl_GetPos(&MenuCommonItem_TitleCtrl, &MenuRect);
	UxCtrl_GetPos(&MenuCommonItem_StatusCtrl, &NewRect);
	NewRect.x1 = MenuRect.x1 + str_size.w + 5   ;
	UxCtrl_SetPos(&MenuCommonItem_StatusCtrl, NewRect);
#endif
//#MT#lyb -20200317 -end

}
//---------------------MenuCommonItemCtrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonItem)
CTRL_LIST_ITEM(MenuCommonItem_List)
CTRL_LIST_ITEM(MenuCommonItem_Panel_Operate)
CTRL_LIST_END

//----------------------MenuCommonItemCtrl Event---------------------------
INT32 MenuCommonItem_OnOpen(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnClose(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_OnStorageChange(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonItem)
EVENT_ITEM(NVTEVT_OPEN_WINDOW, MenuCommonItem_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW, MenuCommonItem_OnClose)
EVENT_ITEM(NVTEVT_CHILD_CLOSE, MenuCommonItem_OnChildClose)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE, MenuCommonItem_OnStorageChange)
EVENT_END


INT32 MenuCommonItem_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;
	TM_OPTION  *pOption;

	MenuCommonItem_SetCurrentMenu(&gSetupMenu);
	pMenu = MenuCommonItem_GetCurrentMenu();

    TM_SetMenu(pMenu);

	pMenu->Status = TMS_ON_ITEM;
	pMenu->SelPage = 0;         // reset page to 0

	pPage = &pMenu->pPages[pMenu->SelPage];
	pPage->SelItem = 0;           // reset item to 0
	//check item if disable
	TM_CheckItemStatus(pMenu, &pPage->SelItem, TRUE);

	pItem = &pPage->pItems[pPage->SelItem];
	pOption = &pItem->pOptions[SysGetFlag(pItem->SysFlag)];

    UxList_SetData(&MenuCommonItem_ListCtrl, LST_CURITM, 0);
    MenuCommonItem_UpdateContent(pMenu);


	Input_SetKeyMask(KEY_PRESS, MENU_KEY_PRESS_MASK);
	Input_SetKeyMask(KEY_RELEASE, MENU_KEY_PRESS_MASK);
	Input_SetKeyMask(KEY_CONTINUE, MENU_KEY_PRESS_MASK);
	Input_SetKeySoundMask(KEY_PRESS, MENU_KEY_PRESS_MASK);

	Ux_DefaultEvent(pCtrl, NVTEVT_OPEN_WINDOW, paramNum, paramArray);

	return NVTEVT_CONSUME;
}
extern BOOL Restart_Rec;
INT32 MenuCommonItem_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_DefaultEvent(pCtrl, NVTEVT_CLOSE_WINDOW, paramNum, paramArray);

	Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_DEFAULT);
	Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_DEFAULT);
	Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_DEFAULT);

	//#NT#2016/08/19#Lincy Lin#[0106935] -begin
	//#NT# Support change WDR, SHDR, RSC setting will change mode after exit menu
	BOOL bReOpenMovie = FlowMovie_CheckReOpenItem();
	BOOL bReOpenPhoto = 0;
#if (PHOTO_MODE==ENABLE)
	bReOpenPhoto = FlowPhoto_CheckReOpenItem();
#endif  
	if(bReOpenMovie)
		exam_msg("RESTART_MODE_YES\r\n");
	else
		exam_msg("RESTART_MODE_NO\r\n");
 

    gMovData.State = MOV_ST_MENU;
#if (UI_FUNC == ENABLE) //zjf 0315
	Save_MenuInfo();
#endif
	DBGD(bReOpenMovie);

	if (bReOpenMovie || bReOpenPhoto)
		//#NT#2016/08/19#Lincy Lin -end
	{
		Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
	}

	return NVTEVT_CONSUME;
}
INT32 MenuCommonItem_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu = MenuCommonItem_GetCurrentMenu();
	//UINT32      uiItem ,uiOption;

//UxButton_SetItemData(&MenuCommonItem_BTN_ReturnCtrl, 0, BTNITM_ICONID, ICON_YES);

	pMenu->Status = TMS_ON_ITEM;
	MenuCommonItem_UpdateContent(pMenu);
	MenuCommonItem_UpdatePosition();
	Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_DEFAULT);
	Ux_DefaultEvent(pCtrl, NVTEVT_CHILD_CLOSE, paramNum, paramArray);

	if (paramNum >= 2) {
		//uiItem = paramArray[0];
		//uiOption = paramArray[1];
	}
	Input_SetKeyMask(KEY_PRESS, MENU_KEY_PRESS_MASK);
	Input_SetKeyMask(KEY_RELEASE, MENU_KEY_RELEASE_MASK);
	Input_SetKeyMask(KEY_CONTINUE, MENU_KEY_CONTINUE_MASK);
	 if (paramNum == 1 && paramArray[0] == 0 )
	 {
		Ux_CloseWindow(&MenuCommonItemCtrl, 0);

	 }
	return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (SDHOTPLUG_FUNCTION == ENABLE)
	Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
#endif
	return NVTEVT_CONSUME;
}
//----------------------MenuCommonItem_ListCtrl Event---------------------------
INT32 MenuCommonItem_List_OnKeyNext(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_List_OnKeyPrev(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_List_OnKeySelect(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_List_OnKeyExit(VControl *, UINT32, UINT32 *);

INT32 MenuCommonItem_List_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_List_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);

EVENT_BEGIN(MenuCommonItem_List)
EVENT_ITEM(NVTEVT_KEY_NEXT, MenuCommonItem_List_OnKeyNext)
EVENT_ITEM(NVTEVT_KEY_PREV, MenuCommonItem_List_OnKeyPrev)
EVENT_ITEM(NVTEVT_KEY_SELECT, MenuCommonItem_List_OnKeySelect)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, MenuCommonItem_List_OnKeyExit)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonItem_List_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonItem_List_OnTouchPanelClick)
//EVENT_ITEM(NVTEVT_USER_DOUBLECLICK,MenuCommonItem_List_OnTouchPanelClick)


EVENT_END

INT32 MenuCommonItem_List_OnKeyNext(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
TESTLOG("");
	if (paramNum == 1) {
		if (paramArray[0] == NVTEVT_KEY_PRESS) {
			pMenu = MenuCommonItem_GetCurrentMenu();
			pPage = &pMenu->pPages[pMenu->SelPage];
			pPage->SelItem++;
			//check item if disable
			TM_CheckItemStatus(pMenu, &pPage->SelItem, TRUE);
			if (pPage->SelItem == pPage->Count) {
				// Close current UI Window now
				Ux_CloseWindow(&MenuCommonItemCtrl, 0);
			} else {
				MenuCommonItem_UpdateContent(pMenu);
				MenuCommonItem_UpdatePosition();
				Ux_SendEvent(pCtrl, NVTEVT_NEXT_ITEM, 0);
			}
		}
	}
	return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_List_OnKeyPrev(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
TESTLOG("");
	if (paramNum == 1) {
		if (paramArray[0] == NVTEVT_KEY_PRESS) {
			pMenu = MenuCommonItem_GetCurrentMenu();
			pPage = &pMenu->pPages[pMenu->SelPage];
			if (pPage->SelItem == 0) {
				// Close current UI Window now
				Ux_CloseWindow(&MenuCommonItemCtrl, 0);
			} else {
				pPage->SelItem--;
				//check item if disable
				TM_CheckItemStatus(pMenu, &pPage->SelItem, FALSE);
				if (pPage->SelItem == pPage->Count) {
					// Close current UI Window now
					Ux_CloseWindow(&MenuCommonItemCtrl, 0);
				} else {
					MenuCommonItem_UpdateContent(pMenu);
					MenuCommonItem_UpdatePosition();
					Ux_SendEvent(pCtrl, NVTEVT_PREVIOUS_ITEM, 0);
				}
			}
		}
	}
	return NVTEVT_CONSUME;
}

#if  0
INT32 MenuCommonItem_List_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;
	TM_OPTION  *pOption;
	TM_MENU    *pNextMenu;
	UINT32      SelOption = 0 ;
TESTLOG("");
	if (paramNum == 1) {
		pMenu = MenuCommonItem_GetCurrentMenu();
		pPage = &pMenu->pPages[pMenu->SelPage];
		pItem = &pPage->pItems[pPage->SelItem];

		if (paramArray[0] == NVTEVT_KEY_PRESS) {
			if (pItem->Count != 0 && pItem->SysFlag != 0 && pItem->ItemId != IDM_COMMON_CLOUD) {
				SelOption = SysGetFlag(pItem->SysFlag);

				SelOption++;
				if (SelOption >= pItem->Count) {
					SelOption = 0;
				}

				SysSetFlag(pItem->SysFlag, SelOption);

				// toggle icon's string
				pOption = &pItem->pOptions[SelOption];
                //#MT#lyb -20200317 -begin
				//UxMenu_SetItemData(&MenuCommonItem_StatusCtrl, 0, MNUITM_STRID,  pOption->TextId);
                //#MT#lyb -20200317 -end

				TM_MENU_CALLBACK(pMenu, TMM_CONFIRM_OPTION, MAKE_LONG(pItem->ItemId, SelOption));
			} else {
				if (pItem->SysFlag == FL_COMMON_MODE) {
					// Enter 2nd level menu and pop up various memu item.
					Ux_OpenWindow(&MenuCommonOptionCtrl, 1, &gModeMenu);
				} else if (pItem->SysFlag == FL_COMMON_MENU) {
					// Enter 2nd level menu and pop up current mode's menu lists
					if (System_GetState(SYS_STATE_CURRMODE) == PRIMARY_MODE_PHOTO) {
						pNextMenu = &gPhotoMenu;
#if (PLAY_MODE == ENABLE)
					} else if (System_GetState(SYS_STATE_CURRMODE) == PRIMARY_MODE_PLAYBACK) {
						pNextMenu = &gPlaybackMenu;
#endif
					} else {
						pNextMenu = &gMovieMenu;
					}
					Ux_OpenWindow(&MenuCommonOptionCtrl, 1, (UINT32)pNextMenu);
				} else if (pItem->SysFlag == FL_COMMON_SETUP) {
					// Enter 2nd level menu and pop up various memu item.
					Ux_OpenWindow(&MenuCommonOptionCtrl, 1, &gSetupMenu);
				} else if (pItem->SysFlag == FL_COMMON_EXT_SETUP) {
					// Enter 2nd level menu and pop up various memu item.
					Ux_OpenWindow(&MenuCommonOptionCtrl, 1, &gExtSetupMenu);
				} else {
					MenuCommonItemErrMsg("not supp %d\r\n", pItem->SysFlag);
				}
			}
		}
	}

	return NVTEVT_CONSUME;
}
#else
INT32 MenuCommonItem_List_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU*    pMenu = MenuCommonItem_GetCurrentMenu();
    TM_PAGE*    pPage;
    TM_ITEM*    pItem;
    
     
    if(paramNum==1)
    {
        if (pMenu->Status == TMS_ON_ITEM)
        {
            pPage = &pMenu->pPages[pMenu->SelPage];
            pItem = &pPage->pItems[pPage->SelItem];

            if (pItem->Count != 0 && pItem->SysFlag != 0)   // standard process
            {
                if (TM_MENU_CALLBACK(pMenu, TMM_ENTER_OPTION, MAKE_LONG(pItem->ItemId, 0)) == TMF_PASS_MESSAGE)
                {
                    return NVTEVT_CONSUME;
                }
            }

            Ux_Redraw();

            if (pItem->Count != 0 && pItem->SysFlag != 0)   // standard process
            {
                pMenu->Status = TMS_ON_OPTION;
                Ux_OpenWindow(&MenuCommonOptionCtrl, 1, pMenu);
            }
            else if (pItem->pOptions != 0)                  // custom process
            {
                pMenu->Status = TMS_ON_CUSTOM;
                TM_ITEM_CALLBACK(pItem, 0, 0);              // execute custom menu flow
            }
        }
    }
    return NVTEVT_CONSUME;
}     
#endif

INT32 MenuCommonItem_List_OnKeyExit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_CloseWindow(&MenuCommonItemCtrl, 0);
	return NVTEVT_CONSUME;
}


BOOL  isCycRec = FALSE;
static BOOL uitempCurItemStatus = STATUS_ENABLE;
INT32 MenuCommonItem_List_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU    *pMenu;
    TM_PAGE    *pPage;
    TM_ITEM    *pItem;
    UINT32 curSelItem = 0;
    UINT32 prevSelItem = 0;

    pMenu = MenuCommonItem_GetCurrentMenu();
    pPage = &pMenu->pPages[pMenu->SelPage];
    pItem = &pPage->pItems[pPage->SelItem];
    prevSelItem = pPage->SelItem;
    curSelItem =   UxList_GetData(&MenuCommonItem_ListCtrl, LST_CURITM);
    TESTLOG("%d, %d", prevSelItem, curSelItem);

	if (curSelItem == 5 )
	{
		isCycRec =TRUE;
	}else{
		isCycRec =FALSE;
	}
    if(prevSelItem != curSelItem)
    {
        pPage->SelItem = curSelItem;
    }
    if(uitempCurItemStatus == STATUS_ENABLE)
    {
        Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
    }

    return NVTEVT_CONSUME;
}
static UINT32 MenuCommonItem_List_CalcShiftFrom1stItem(UINT32 x, UINT32 y, Ux_RECT* ListRect, UINT32 item_per_line, UINT32 colum_total)
{
    UINT32 shiftNum = 0;
    UINT32 shiftNum_x,shiftNum_y = 0;
    UINT32 ItemWidth,ItemHeight = 0;
    ItemHeight = (ListRect->y2 - ListRect->y1)/colum_total;
    ItemWidth = (ListRect->x2 - ListRect->x1)/item_per_line;

    if(y < (UINT32)(ListRect->y1) || y > (UINT32)(ListRect->y2) || x < (UINT32)(ListRect->x1) || x > (UINT32)(ListRect->x2))
        return 0xffff;
    shiftNum_x = (x-ListRect->x1)/ItemWidth;
    shiftNum_y = (y-ListRect->y1)/ItemHeight;
    shiftNum = (shiftNum_x + shiftNum_y*item_per_line);
    if(UxList_GetItemData(&MenuCommonItem_ListCtrl, shiftNum, LSTITM_STATUS) == STATUS_ENABLE){
        uitempCurItemStatus = STATUS_ENABLE;
        return shiftNum;
    } else {
        uitempCurItemStatus = STATUS_DISABLE;
    }
    return 0xffff;
}
INT32 MenuCommonItem_List_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;
	Ux_RECT ListRect;
	UINT32 uiPressIndex;
	pMenu = MenuCommonItem_GetCurrentMenu();
	pPage = &pMenu->pPages[pMenu->SelPage];
	pItem = &pPage->pItems[pPage->SelItem];
	UxList_GetRange(&MenuCommonItem_ListCtrl,&ListRect);
	uiPressIndex = MenuCommonItem_List_CalcShiftFrom1stItem(paramArray[0], paramArray[1], &ListRect, 6, 2);
	if(uiPressIndex != 0xffff)
	{
       UxList_SetData(&MenuCommonItem_ListCtrl, LST_CURITM, uiPressIndex);
       MenuCommonItem_UpdateContent(pMenu);
	}
    return NVTEVT_CONSUME;
}



//---------------------MenuCommonItem_Panel_OperateCtrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonItem_Panel_Operate)
CTRL_LIST_ITEM(MenuCommonItem_BTN_Return)
CTRL_LIST_ITEM(MenuCommonItem_BTN_Exit)
CTRL_LIST_END

//----------------------MenuCommonItem_Panel_OperateCtrl Event---------------------------
EVENT_BEGIN(MenuCommonItem_Panel_Operate)
EVENT_END

//----------------------MenuCommonItem_BTN_RecURGCtrl Event---------------------------
INT32 MenuCommonItem_BTN_Return_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN_Return_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN_Return_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonItem_BTN_Return)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonItem_BTN_Return_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_USER_RELEASE,MenuCommonItem_BTN_Return_OnTouchPanelRelease)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonItem_BTN_Return_OnTouchPanelClick)
EVENT_END

INT32 MenuCommonItem_BTN_Return_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UxButton_SetItemData(&MenuCommonItem_BTN_ReturnCtrl, 0, BTNITM_ICONID, ICON_OPERATE_RETURN_F);
    return NVTEVT_CONSUME;
}


INT32 MenuCommonItem_BTN_Return_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UxButton_SetItemData(&MenuCommonItem_BTN_ReturnCtrl, 0, BTNITM_ICONID, ICON_OPERATE_RETURN);
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_BTN_Return_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_CloseWindow(&MenuCommonItemCtrl, 0);
    return NVTEVT_CONSUME;
}

//----------------------MenuCommonItem_BTN_ExitCtrl Event---------------------------
INT32 MenuCommonItem_BTN_Exit_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN_Exit_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
INT32 MenuCommonItem_BTN_Exit_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonItem_BTN_Exit)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonItem_BTN_Exit_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_USER_RELEASE,MenuCommonItem_BTN_Exit_OnTouchPanelRelease)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonItem_BTN_Exit_OnTouchPanelClick)
EVENT_END

INT32 MenuCommonItem_BTN_Exit_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UxButton_SetItemData(&MenuCommonItem_BTN_ExitCtrl, 0, BTNITM_ICONID, ICON_OPERATE_EXIT_F);
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_BTN_Exit_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UxButton_SetItemData(&MenuCommonItem_BTN_ExitCtrl, 0, BTNITM_ICONID, ICON_OPERATE_EXIT);
    return NVTEVT_CONSUME;
}

INT32 MenuCommonItem_BTN_Exit_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	    Ux_CloseWindow(&MenuCommonItemCtrl, 0);

    return NVTEVT_CONSUME;
}

