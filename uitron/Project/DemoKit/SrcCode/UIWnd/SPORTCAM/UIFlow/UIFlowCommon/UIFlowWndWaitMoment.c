//This source code is generated by UI Designer Studio.
#include "AppLib.h"
#include "FileSysTsk.h"
#include "EthCamAppCmd.h"
#include "UIModeUpdFw.h"
#include "EthCamAppSocket.h"
#include "EthCamSocket.h"
#include "EthCamAppNetwork.h"
#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "UIGraphics.h"
#include "NVTToolCommand.h"
#include "UIFlowWndWaitMomentRes.c"
#include "UIFlow.h"
#include "UIFlowWndWaitMoment.h"
#include "PrjCfg.h"
#define THIS_DBGLVL         2 // 0=FATAL, 1=ERR, 2=WRN, 3=UNIT, 4=FUNC, 5=IND, 6=MSG, 7=VALUE, 8=USER
///////////////////////////////////////////////////////////////////////////////
#define __MODULE__          UIFlowWndWaitMoment
#define __DBGLVL__          ((THIS_DBGLVL>=PRJ_DBG_LVL)?THIS_DBGLVL:PRJ_DBG_LVL)
#define __DBGFLT__          "*" //*=All, [mark]=CustomClass
#include "DebugModule.h"
//-----------------------------------------------------------------------------
// UIFlowWndWaitMoment User Variable & Function Declarations
//-----------------------------------------------------------------------------
static UINT32 g_uiWaitMomentMsg     = 0;
static UINT32 g_uiRestart_Rec     = 0;
static char g_StringTmpBuf[64] = {0};
static UINT32  g_UIStopRecTimerID = NULL_TIMER;
static BOOL g_bRecStopFinish     = 0;
static UINT32 g_uiRecStopTimerCnt     = 0;
static UINT32  g_UIDetBackTimerID = NULL_TIMER;
static UINT32 g_uiDetBack_Rec     = 0;
static UINT32 g_UIShowProgressBarTimerID =NULL_TIMER; 
#define TIMER_STOP 0
#define TIMER_START 1
//---------------------UIFlowWndWaitMomentCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndWaitMoment)
CTRL_LIST_ITEM(UIFlowWndWaitMoment_StatusTXT_Msg)
CTRL_LIST_ITEM(UIFlowWndWaitMomentButtonNo)
CTRL_LIST_ITEM(UIFlowWndWaitMomentButtonYes)
CTRL_LIST_ITEM(UIFlowWndWaitMoment_ProgressBar)
CTRL_LIST_END

//----------------------UIFlowWndWaitMomentCtrl Event---------------------------
INT32 UIFlowWndWaitMoment_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndWaitMoment_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndWaitMoment_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndWaitMoment_OnBackgroundDone(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndWaitMoment_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndWaitMoment_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndWaitMoment_OnTouchRelease(VControl *, UINT32, UINT32 *);

EVENT_BEGIN(UIFlowWndWaitMoment)
EVENT_ITEM(NVTEVT_OPEN_WINDOW, UIFlowWndWaitMoment_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW, UIFlowWndWaitMoment_OnClose)
EVENT_ITEM(NVTEVT_TIMER, UIFlowWndWaitMoment_OnTimer)
EVENT_ITEM(NVTEVT_BACKGROUND_DONE, UIFlowWndWaitMoment_OnBackgroundDone)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, UIFlowWndWaitMoment_OnKeyShutter2)
EVENT_ITEM(NVTEVT_CHILD_CLOSE, UIFlowWndWaitMoment_OnChildClose)
EVENT_ITEM(NVTEVT_USER_RELEASE, UIFlowWndWaitMoment_OnTouchRelease)
EVENT_END

#define MASK_ALL					0xffffffff

void Ignore_func(void )
{
	if(TIMER_STOP){
		return;
	}else{
		return;
	}
}

extern UINT32 g_EthcamFwSize;
extern UINT32 g_EthcamFwUpdateTimes;
static UINT32 EthCamFwUpdatingTimes = 0;
static BOOL Ethcam_Tx_FwUpdate(void)
{
	CHKPNT;
    BOOL bRet = FALSE;
    
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DATA1 ,ETHCAM_CMD_TX_STREAM_STOP, 0);
#if (ETH_REARCAM_CLONE_FOR_DISPLAY == ENABLE)
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DATA2 ,ETHCAM_CMD_TX_STREAM_STOP, 0);
#endif
	Delay_DelayMs(500);  

	System_ChangeSubMode(SYS_SUBMODE_UPDFW);
	Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_UPDFW);
	
	BKG_PostEvent(NVTEVT_BKW_ETHCAM_FW_UPDATE);// must be BKG ,if not ,progressbar can not be changed
	
	return bRet;
}

static INT8 UIFlowWndWaitMoment_StopOrStartDetBackTimer(BOOL status )
{
	if(status == TIMER_STOP){
		if (g_UIDetBackTimerID != NULL_TIMER) {
			GxTimer_StopTimer(&g_UIDetBackTimerID);
		}else{
			debug_msg("g_UIDetBackTimerID is NULL\r\n");
		}
		return 1;
	}else if(status == TIMER_START){
		if (g_UIDetBackTimerID == NULL_TIMER) {
			g_UIDetBackTimerID = GxTimer_StartTimer(1000, NVTEVT_1SEC_TIMER, CONTINUE);
			g_uiDetBack_Rec =3;
		}else{
			debug_msg("g_UIDetBackTimerID is not NULL\r\n");
		}
		
		return 1;
	}else{
		return -1;
	}
}

static INT8 UIFlowWndWaitMoment_StopOrStartRecTimer(BOOL status )
{
	if(status == TIMER_STOP){
		if (g_UIStopRecTimerID != NULL_TIMER) {
			GxTimer_StopTimer(&g_UIStopRecTimerID);
		}else{
			debug_msg("g_UIStopRecTimerID is NULL\r\n");
		}
		return 1;
	}else if(status == TIMER_START){
        if (g_UIStopRecTimerID == NULL_TIMER) {
	        g_UIStopRecTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
	        g_uiRecStopTimerCnt=3;
        }else{
			debug_msg("g_UIStopRecTimerID is not NULL\r\n");
		}
		return 1;
	}else{
		return -1;
	}
}

static INT8 UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(BOOL status )
{
	if(status == TIMER_STOP){
		if (g_UIShowProgressBarTimerID != NULL_TIMER) {
			GxTimer_StopTimer(&g_UIShowProgressBarTimerID);
		}else{
			debug_msg("g_UIShowProgressBarTimerID is NULL\r\n");
		}
		return 1;
	}else if(status == TIMER_START){
        if (g_UIShowProgressBarTimerID == NULL_TIMER) {
	        g_UIShowProgressBarTimerID = GxTimer_StartTimer(500, NVTEVT_05SEC_TIMER, CONTINUE);
        }else{
			debug_msg("g_UIShowProgressBarTimerID is not NULL\r\n");
		}
		return 1;
	}else{
		return -1;
	}
}


static BOOL g_TouchReleaseFunc_Enable = FALSE;
extern INT8 ethsocket_sendsize;
INT32 UIFlowWndWaitMoment_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{  

	UI_SetTouchEventMask(MASK_ALL);

	UxCtrl_SetShow(&UIFlowWndWaitMomentButtonNoCtrl, FALSE);
	UxCtrl_SetShow(&UIFlowWndWaitMomentButtonYesCtrl, FALSE);
    UxCtrl_SetShow(&UIFlowWndWaitMoment_ProgressBarCtrl, FALSE);
	
    g_uiRestart_Rec=0;
    g_bRecStopFinish=0;
	
	UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_START);
	UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_START);
	UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_START);
	CHKPNT;
	UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
	UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
	UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
	
	g_TouchReleaseFunc_Enable = FALSE;
	if (paramNum > 0) {
		g_uiWaitMomentMsg = paramArray[0];
		debug_ind(("UIFlowWndWaitMoment: Msg = 0x%x\r\n", g_uiWaitMomentMsg));
	}
	
	if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ENTER_PARKING == g_uiWaitMomentMsg){
		CHKPNT;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ENTER_PARKING);
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if (UIFlowWndWaitMoment_StatusTXT_Msg_STRID_FORMACT_SD == g_uiWaitMomentMsg){
		CHKPNT;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_FORMACT_SD);
		UxCtrl_SetShow(&UIFlowWndWaitMomentButtonNoCtrl, TRUE);
		UxCtrl_SetShow(&UIFlowWndWaitMomentButtonYesCtrl, TRUE);
		g_TouchReleaseFunc_Enable = FALSE;
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if (UIFlowWndWaitMoment_StatusTXT_Msg_STRID_PLEASE_WAIT == g_uiWaitMomentMsg){
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_PLEASE_WAIT);
		g_uiDetBack_Rec=0;
		CHKPNT;
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_START);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if (UIFlowWndWaitMoment_StatusTXT_Msg_STRID_SLOW_CARD == g_uiWaitMomentMsg){
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_SLOW_CARD);
		g_uiDetBack_Rec=0;
		CHKPNT;
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_START);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if ( UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_DETFAIL==g_uiWaitMomentMsg ){
		CHKPNT;
		g_TouchReleaseFunc_Enable = ENABLE;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_DETFAIL);
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_START);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else  if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_RESTART_REC==g_uiWaitMomentMsg){
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_RESTART_REC);
		CHKPNT;
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_STOPREC_WAIT==g_uiWaitMomentMsg){
		CHKPNT;
		if (paramNum == 2){
			UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_PLEASE_WAIT);
		}else{
			UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_STOPREC_WAIT);
		}
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_START);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
    }else if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_SENDFW==g_uiWaitMomentMsg){
    	CHKPNT;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_SENDFW);
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_START);
		
    }else if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_START==g_uiWaitMomentMsg){
		CHKPNT;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_START);
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_FINISH==g_uiWaitMomentMsg){
		CHKPNT;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_FINISH);
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if (UIFlowWndWaitMoment_StatusTXT_Msg_STRID_MOVIE_BACK_MSG==g_uiWaitMomentMsg ){
		CHKPNT;
		g_TouchReleaseFunc_Enable = ENABLE;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_MOVIE_BACK_MSG);
		g_uiDetBack_Rec=0;
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_START);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_CHANGE_BEHINDCAM == g_uiWaitMomentMsg){
		CHKPNT;
		g_TouchReleaseFunc_Enable = ENABLE;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, g_uiWaitMomentMsg );
		g_uiDetBack_Rec=0;
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_START);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_CHANGE_FRONTCAM == g_uiWaitMomentMsg){
		CHKPNT;
		g_TouchReleaseFunc_Enable = ENABLE;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, g_uiWaitMomentMsg );
		g_uiDetBack_Rec=0;
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_START);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ENTER_SHUTDOWN == g_uiWaitMomentMsg){
		CHKPNT;
		UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, g_uiWaitMomentMsg );
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
	}else{
		CHKPNT;
    	UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, g_uiWaitMomentMsg);
		UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP);
		UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
		
    }
	UxCtrl_SetShow(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, TRUE);

	if(UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_SENDFW==g_uiWaitMomentMsg){
		Ethcam_Tx_FwUpdate();	
	}
	Ux_DefaultEvent(pCtrl, NVTEVT_OPEN_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndWaitMoment_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	CHKPNT;
	g_uiRestart_Rec=0;
	if (g_UIStopRecTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_UIStopRecTimerID);
	}   

	g_uiDetBack_Rec=0;
	if (g_UIDetBackTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_UIDetBackTimerID);
//		Ux_CloseWindow(& UIFlowWndWaitMomentCtrl, 0);
	}   
	
	EthCamFwUpdatingTimes = 0;
	g_EthcamFwUpdateTimes = 0;
	ethsocket_sendsize = 0;
	UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);		
	Ux_DefaultEvent(pCtrl, NVTEVT_CLOSE_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32  UIFlowWndWaitMoment_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	CHKPNT;
	g_uiRestart_Rec=0;
	if (g_UIStopRecTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_UIStopRecTimerID);
	}   
    
	g_uiDetBack_Rec=0;
	if (g_UIDetBackTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_UIDetBackTimerID);
	}   
	UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);		
	Ux_DefaultEvent(pCtrl, NVTEVT_CHILD_CLOSE, paramNum, paramArray);
	return NVTEVT_CONSUME;

}
extern BOOL isEnterParkingMode;
extern BOOL isOpenMsgWin;
INT32 UIFlowWndWaitMoment_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiEvent;
	uiEvent = paramNum ? paramArray[0] : 0;
	switch (uiEvent) {
	case NVTEVT_01SEC_TIMER:
		debug_msg("on timer --cj g_uiRecStopTimerCnt:%d  %d \r\n", g_uiRecStopTimerCnt, g_bRecStopFinish);
        	if(g_uiRecStopTimerCnt){
        	    g_uiRecStopTimerCnt--;
        	    if(g_bRecStopFinish && g_uiRecStopTimerCnt==0){
        	        debug_ind(("WaitMoment Timer Close Wnd\r\n"));
					CHKPNT;
        	        Ux_CloseWindow(pCtrl, 2, NVTRET_WAITMOMENT, 0);
        	    }
        	}else if ( g_uiRecStopTimerCnt==0){
        	// g_bRecStopFinish &&
			      debug_ind(("WaitMoment Timer Close Wnd\r\n"));
					CHKPNT;
					if(UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP) == -1){
						debug_msg("Stop DetBackTimer err\r\n");
					}
					if(UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP) == -1){
						debug_msg("Stop RecTimer err\r\n");
					}
					if(UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP) == -1){
						debug_msg("Stop RecTimer err\r\n");
					}
        	        Ux_CloseWindow(pCtrl, 2, NVTRET_WAITMOMENT, 0);
        	}
		break;
	case  NVTEVT_05SEC_TIMER:
		{
			//debug_msg("-----on timer showprogressbar\r\n");
			if(ethsocket_sendsize>99){
				//UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP);
				//UxCtrl_SetShow(&UIFlowWndWaitMoment_ProgressBarCtrl, FALSE);
				//DBGD(g_EthcamFwUpdateTimes);
				if(g_EthcamFwUpdateTimes){
					if(EthCamFwUpdatingTimes < g_EthcamFwUpdateTimes){
						UxProgressBar_SetData(&UIFlowWndWaitMoment_ProgressBarCtrl,PROBAR_CURSTP, EthCamFwUpdatingTimes++);
						UxProgressBar_SetData(&UIFlowWndWaitMoment_ProgressBarCtrl,PROBAR_TOTSTP,g_EthcamFwUpdateTimes);
						UxCtrl_SetShow(&UIFlowWndWaitMoment_ProgressBarCtrl, TRUE);
					}else{
						CHKPNT;
					}
				}
			}else{
				DBGD(ethsocket_sendsize);
				if(ethsocket_sendsize){
					UxProgressBar_SetData(&UIFlowWndWaitMoment_ProgressBarCtrl,PROBAR_CURSTP, ethsocket_sendsize);
					UxProgressBar_SetData(&UIFlowWndWaitMoment_ProgressBarCtrl,PROBAR_TOTSTP,99);
					UxCtrl_SetShow(&UIFlowWndWaitMoment_ProgressBarCtrl, TRUE);
				}else{
					UxCtrl_SetShow(&UIFlowWndWaitMoment_ProgressBarCtrl, FALSE);
				}
			}
		}break;
		
	case  NVTEVT_1SEC_TIMER:
		
			debug_msg("on timer --cj g_uiDetBack_Rec:%d  \r\n", g_uiDetBack_Rec);
			if((!(g_uiDetBack_Rec > 0)) && isEnterParkingMode == FALSE && !isOpenMsgWin){
				CHKPNT;
				if(!isEnterParkingMode){
					if(UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP) == -1){
						debug_msg("Stop DetBackTimer err\r\n");
					}
					if(UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP) == -1){
						debug_msg("Stop RecTimer err\r\n");
					}
					if(UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP) == -1){
						debug_msg("Stop ProgressBarTimer err\r\n");
					}
					Ux_CloseWindow(pCtrl, 1,0);
				}
			}else{
				g_uiDetBack_Rec--;
			}
		break;
	}
	return NVTEVT_CONSUME;
}

extern BOOL 	g_closeformatwnd;	
extern BOOL bSDFormat;
INT32 UIFlowWndWaitMoment_OnBackgroundDone(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	NVTEVT event;
	UINT32 uiReturn = 0;
	UINT32 status;

	event = paramArray[ONDONE_PARAM_INDEX_CMD];
	status = paramArray[ONDONE_PARAM_INDEX_RET];
	debug_ind(("UIFlowWndWaitMoment OnBackgroundDone event = 0x%x, status=%d\r\n", event, status));

	switch (event) {
	case NVTEVT_BKW_COPY2CARD: {
			switch (status) {
			case 1: // TRUE
				uiReturn = NVTRET_COPY2CARD;
				break;
			case 0:
				uiReturn = NVTRET_CANCEL;
			}
			//Rsvd
			break;
		}

	case NVTEVT_BKW_DELALL: {
			uiReturn = NVTRET_DELETEALL;
			//Rsvd
			break;
		}

	case NVTEVT_BKW_FORMAT_CARD: {
			uiReturn = NVTRET_FORMAT;
			g_closeformatwnd=TRUE;	
			//Rsvd
			break;
		}

	case NVTEVT_BKW_FORMAT_NAND: {
			uiReturn = NVTRET_FORMAT;
			//Rsvd
			break;
		}

	case NVTEVT_BKW_FORMAT: {
			uiReturn = NVTRET_FORMAT;
			//Rsvd
			break;
		}

	case NVTEVT_BKW_SETPROTECT: {
			uiReturn = NVTRET_PROTECT;
			//Rsvd
			break;
		}
	case NVTEVT_BKW_WIFI_ON: {
#if (WIFI_FUNC==ENABLE)
			Ux_PostEvent(NVTEVT_SYSTEM_MODE, 2, PRIMARY_MODE_MOVIE, SYS_SUBMODE_WIFI);
#endif
			return NVTEVT_CONSUME;
		}
	case NVTEVT_BKW_FW_UPDATE: {
			if (status) {
				debug_err(("%s:update FW fail %d\r\n", __FUNCTION__, status));
			} else {
				Delay_DelayMs(2000);
				// Should power off immediatelly
				System_PowerOff(SYS_POWEROFF_NORMAL);
			}
			break;
		}
	case NVTEVT_BKW_STOPREC_PROCESS: {
			//debug_err(("NVTEVT_BKW_STOPREC_PROCESS, Restart_Rec=%d\r\n",g_uiRestart_Rec));
			//Delay_DelayMs(300);
			//#NT#2018/09/14#KCHong -begin
			//#NT# retore key mask when stop record flow done
			Input_SetKeyMask(KEY_PRESS, (FLGKEY_SHUTTER2|FLGKEY_RIGHT|FLGKEY_LEFT|FLGKEY_CUSTOM1|FLGKEY_UP|FLGKEY_DOWN));
			//#NT#2018/09/14#KCHong -end
			if(g_uiRestart_Rec){
				CHKPNT;
        		uiReturn = NVTRET_RESTART_REC;
			}else{
				uiReturn = 0;
				CHKPNT;
				g_bRecStopFinish=1;
				if(g_uiRecStopTimerCnt){
				    return NVTEVT_CONSUME;
				}
			}
		}
			break;
	case NVTEVT_BKW_ETHCAM_FW_UPDATE: {
		CHKPNT;
		if(status == NVTRET_OK){
			UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_START);
		}else if (status == NVTRET_ERROR){
			UxState_SetData(&UIFlowWndWaitMoment_StatusTXT_MsgCtrl, STATE_CURITEM, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_SENDFW_FAILED);
		}
		return NVTEVT_CONSUME;
	}
	default:
		uiReturn = NVTRET_ERROR;
		debug_err(("UIFlowWndWaitMoment OnBackgroundDone: Unknown event 0x%x\r\n", event));
		break;
	}
	if ( !bSDFormat )
	{
		Ux_CloseWindow(pCtrl, 2, NVTRET_WAITMOMENT, uiReturn);
	}else {
		// do nothing !
	}
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndWaitMoment_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiKeyAct;
	UINT32 uiState;

	//debug_err(("UIFlowWndWaitMoment_OnKeyShutter2 \r\n"));
	uiKeyAct = paramNum ? paramArray[0] : 0;

	if (paramNum >= 3) {
		uiState = paramArray[2];
	} else {
		uiState = 0;
	}

	//debug_err(("uiKeyAct=%d, uiState=0x%x\r\n",uiKeyAct,uiState));
	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		//debug_err(("NVTEVT_KEY_PRESS\r\n"));
		if (uiState == UIFlowWndMovie_Restart_Rec) {
			g_uiRestart_Rec = 1;
		} else {
			g_uiRestart_Rec = 0;
		}   
	break;
		}

	return NVTEVT_CONSUME;
}

//----------------------UIFlowWndWaitMoment_StatusTXT_MsgCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndWaitMoment_StatusTXT_Msg)
EVENT_END

//----------------------UIFlowWndWaitMoment_Operate_Tab_YES_NOCtrl Event---------------------------
INT32 UIFlowWndWaitMoment_Operate_Tab_YES_NO_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndWaitMoment_Operate_Tab_YES_NO_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndWaitMoment_Operate_Tab_YES_NO_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
//EVENT_BEGIN(UIFlowWndWaitMoment_Operate_Tab_YES_NO)
//EVENT_ITEM(NVTEVT_CLICK,UIFlowWndWaitMoment_Operate_Tab_YES_NO_OnTouchPanelClick)
//EVENT_ITEM(NVTEVT_RELEASE,UIFlowWndWaitMoment_Operate_Tab_YES_NO_OnTouchPanelRelease)
//EVENT_END

INT32 UIFlowWndWaitMoment_Operate_Tab_YES_NO_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
   // Ux_SendEvent(pCtrl,NVTEVT_PREVIOUS_ITEM,0);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndWaitMoment_Operate_Tab_YES_NO_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
   // Ux_SendEvent(pCtrl,NVTEVT_NEXT_ITEM,0);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndWaitMoment_Operate_Tab_YES_NO_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndWaitMomentButtonNoCtrl Event---------------------------
INT32 UIFlowWndWaitMomentButtonNo_OnTouchPanelClick(VControl *, UINT32, UINT32 *);

EVENT_BEGIN(UIFlowWndWaitMomentButtonNo)
EVENT_ITEM(NVTEVT_CLICK,UIFlowWndWaitMomentButtonNo_OnTouchPanelClick)

EVENT_END
INT32 UIFlowWndWaitMomentButtonNo_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
CHKPNT;
     Ux_CloseWindow(&UIFlowWndWaitMomentCtrl, 2, NVTRET_WAITMOMENT, 0);
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndWaitMomentButtonYesCtrl Event---------------------------
INT32 UIFlowWndWaitMomentButtonYes_OnTouchPanelClick(VControl *, UINT32, UINT32 *);

EVENT_BEGIN(UIFlowWndWaitMomentButtonYes)
EVENT_ITEM(NVTEVT_CLICK,UIFlowWndWaitMomentButtonYes_OnTouchPanelClick)

EVENT_END
INT32 UIFlowWndWaitMomentButtonYes_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	//CHKPNT;
    Ux_OpenWindow(&UIMenuWndSetupFormatConfirmCtrl, 1, 0);

	/* BKG_PostEvent(NVTEVT_BKW_FORMAT_CARD);
	 if (g_UIDetBackTimerID == NULL_TIMER) {
				g_UIDetBackTimerID = GxTimer_StartTimer(1000, NVTEVT_1SEC_TIMER, CONTINUE);
				g_uiDetBack_Rec =3;
			}   

	//*/
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndWaitMoment_OnTouchRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if(g_TouchReleaseFunc_Enable == ENABLE){
		if(UIFlowWndWaitMoment_StopOrStartDetBackTimer(TIMER_STOP) == -1){
			debug_msg("Stop DetBackTimer err\r\n");
		}
		
		if(UIFlowWndWaitMoment_StopOrStartRecTimer(TIMER_STOP) == -1){
			debug_msg("Stop RecTimer err\r\n");
		}
		if(UIFlowWndWaitMoment_StopOrStartShowProgressBarTimer(TIMER_STOP) == -1){
			debug_msg("Stop RecTimer err\r\n");
		}
		Ux_CloseWindow(pCtrl,2, NVTRET_WAITMOMENT,NVTEVT_RELEASE);
	}
    return NVTEVT_PASS;
}
//----------------------UIFlowWndWaitMoment_ProgressBarCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndWaitMoment_ProgressBar)
EVENT_END

